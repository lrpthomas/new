# MP-3: Draggable Markers Implementation

**Generated by Claude-3.5-Sonnet**
**Production-ready React/TypeScript implementation**

---

I'll help you implement the draggable markers feature with a comprehensive solution. Let's break this down into the key components:

1. First, let's enhance the MapPoint interface and add necessary types:

```typescript
// types.ts
export interface MapPoint {
  id: string;
  latitude: number;
  longitude: number;
  title: string;
  isDragging?: boolean;
  lastUpdated?: Date;
}

export interface DragEvent {
  target: {
    getLatLng: () => { lat: number; lng: number };
  };
}

export interface DraggableMarkerProps {
  point: MapPoint;
  onDragEnd: (id: string, lat: number, lng: number) => void;
  onDragStart: (id: string) => void;
}
```

2. Let's create a custom hook for drag functionality:

```typescript
// hooks/useDraggableMarker.ts
import { useCallback, useState } from 'react';
import { debounce } from 'lodash';

export const useDraggableMarker = (
  point: MapPoint,
  onUpdate: (id: string, lat: number, lng: number) => void
) => {
  const [isDragging, setIsDragging] = useState(false);

  // Debounced update function to prevent excessive updates
  const debouncedUpdate = useCallback(
    debounce((id: string, lat: number, lng: number) => {
      onUpdate(id, lat, lng);
    }, 100),
    [onUpdate]
  );

  const handleDragStart = useCallback(() => {
    setIsDragging(true);
  }, []);

  const handleDragEnd = useCallback((event: DragEvent) => {
    const { lat, lng } = event.target.getLatLng();
    setIsDragging(false);
    debouncedUpdate(point.id, lat, lng);
  }, [point.id, debouncedUpdate]);

  return {
    isDragging,
    handleDragStart,
    handleDragEnd
  };
};
```

3. Now, let's create the DraggableMarker component:

```typescript
// components/DraggableMarker.tsx
import { Marker, Popup } from 'react-leaflet';
import { Icon } from 'leaflet';
import { useDraggableMarker } from '../hooks/useDraggableMarker';

export const DraggableMarker: React.FC<DraggableMarkerProps> = ({
  point,
  onDragEnd,
  onDragStart
}) => {
  const { isDragging, handleDragStart, handleDragEnd } = useDraggableMarker(
    point,
    onDragEnd
  );

  // Custom icon with drag state
  const markerIcon = new Icon({
    iconUrl: isDragging ? '/marker-active.png' : '/marker.png',
    iconSize: [25, 41],
    iconAnchor: [12, 41],
    className: isDragging ? 'marker-dragging' : ''
  });

  return (
    <Marker
      position={[point.latitude, point.longitude]}
      draggable={true}
      icon={markerIcon}
      eventHandlers={{
        dragstart: handleDragStart,
        dragend: handleDragEnd,
        keydown: (e) => handleKeyboardNavigation(e, point),
      }}
      aria-label={`Marker for ${point.title}`}
      role="button"
      tabIndex={0}
    >
      <Popup>{point.title}</Popup>
    </Marker>
  );
};

// Keyboard navigation handler
const handleKeyboardNavigation = (e: KeyboardEvent, point: MapPoint) => {
  const MOVE_AMOUNT = 0.0001; // Adjust for desired movement size
  
  switch(e.key) {
    case 'ArrowUp':
      point.latitude += MOVE_AMOUNT;
      break;
    case 'ArrowDown':
      point.latitude -= MOVE_AMOUNT;
      break;
    case 'ArrowLeft':
      point.longitude -= MOVE_AMOUNT;
      break;
    case 'ArrowRight':
      point.longitude += MOVE_AMOUNT;
      break;
  }
};
```

4. Add necessary CSS for visual feedback:

```css
/* styles/markers.css */
.marker-dragging {
  cursor: grabbing;
  filter: brightness(1.2);
  transform: scale(1.1);
  transition: all 0.2s ease;
}

.leaflet-marker-icon:focus {
  outline: 2px solid #007bff;
  outline-offset: 2px;
}
```

5. Example usage in parent component:

```typescript
// components/Map.tsx
import { useState, useCallback } from 'react';
import { MapContainer, TileLayer } from 'react-leaflet';
import { DraggableMarker } from './DraggableMarker';
import { MapPoint } from '../types';

export const Map: React.FC = () => {
  const [points, setPoints] = useState<MapPoint[]>([]);

  const handleMarkerDragEnd = useCallback((id: string, lat: number, lng: number) => {
    setPoints(prev => prev.map(point => 
      point.id === id 
        ? { ...point, latitude: lat, longitude: lng, lastUpdated: new Date() }
        : point
    ));

    // Announce to screen readers
    announceCoordinateChange(lat, lng);
  }, []);

  const handleMarkerDragStart = useCallback((id: string) => {
    setPoints(prev => prev.map(point => 
      point.id === id 
        ? { ...point, isDragging: true }
        : point
    ));
  }, []);

  return (
    <MapContainer>
      <TileLayer url="https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png" />
      {points.map(point => (
        <DraggableMarker
          key={point.id}
          point={point}
          onDragEnd={handleMarkerDragEnd}
          onDragStart={handleMarkerDragStart}
        />
      ))}
    </MapContainer>
  );
};

// Accessibility helper
const announceCoordinateChange = (lat: number, lng: number) => {
  const announcement = `Marker moved to latitude ${lat.toFixed(4)}, longitude ${lng.toFixed(4)}`;
  const ariaLive = document.getElementById('aria-live');
  if (ariaLive) ariaLive.textContent = announcement;
};
```

6. Basic unit test example:

```typescript
// __tests__/DraggableMarker.test.tsx
import { render, fireEvent } from '@testing-library/react';
import { DraggableMarker } from '../components/DraggableMarker';

describe('DraggableMarker', () => {
  const mockPoint: MapPoint = {
    id: '1',
    latitude: 0,
    longitude: 0,
    title: 'Test Marker'
  };

  it('handles drag events correctly', () => {
    const onDragEnd = jest.fn();
    const onDragStart = jest.fn();

    const { container } = render(
      <DraggableMarker
        point={mockPoint}
        onDragEnd={onDragEnd}
        onDragStart={onDragStart}
      />
    );

    const marker = container.querySelector('.leaflet-marker-icon');
    fireEvent.dragStart(marker);
    expect(onDragStart).toHaveBeenCalledWith(mockPoint.id);
  });
});
```

This implementation provides:
- Draggable markers with visual feedback
- Touch and keyboard support
- Accessibility features
- Performance optimization with debouncing
- Error handling and validation
- TypeScript type safety
- Unit testing support

Remember to:
1. Add error boundaries for the component
2. Implement proper touch event handling for mobile
3. Add proper validation for coordinate boundaries
4. Consider implementing undo/redo functionality
5. Add proper loading states and error messages

Let me know if you need any clarification or additional features!