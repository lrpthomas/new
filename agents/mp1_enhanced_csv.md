# MP-1: Enhanced CSV Validation

Generated by BACKEND_AGENT

Here's a comprehensive CSV validation system for Maptap that meets the requirements:

```typescript
// types.ts
export interface MapPoint {
  position: string;
  latlng: [number, number];
  [key: string]: any;
}

export interface ValidationError {
  line: number;
  field: string;
  value: string;
  message: string;
  suggestion?: string;
}

export interface ValidationResult {
  isValid: boolean;
  errors: ValidationError[];
  data: MapPoint[];
}

// csvValidator.ts
import { createMapPoint } from './mapPointHelper';
import { MapPoint, ValidationError, ValidationResult } from './types';
import { Transform, TransformCallback } from 'stream';

export class CSVValidator {
  private static COORDINATE_PATTERNS = {
    DECIMAL: /^-?\d+\.?\d*$/,
    DMS: /^(-?\d+)°\s*(\d+)'\s*(\d+(\.\d+)?)"([NS])?$/,
    LAT_RANGE: [-90, 90],
    LNG_RANGE: [-180, 180]
  };

  private static HEADERS = {
    LATITUDE: ['lat', 'latitude', 'y'],
    LONGITUDE: ['lng', 'longitude', 'lon', 'x']
  };

  static async validateCSV(
    stream: NodeJS.ReadableStream,
    options = { chunkSize: 1000 }
  ): Promise<ValidationResult> {
    const result: ValidationResult = {
      isValid: true,
      errors: [],
      data: []
    };

    let headers: string[] = [];
    let lineNumber = 0;

    const transformer = new Transform({
      objectMode: true,
      transform(chunk: Buffer, encoding: string, callback: TransformCallback) {
        const lines = chunk.toString().split('\n');
        
        lines.forEach((line, index) => {
          if (lineNumber === 0) {
            headers = CSVValidator.parseHeaders(line);
            if (!CSVValidator.validateHeaders(headers)) {
              result.errors.push({
                line: 0,
                field: 'headers',
                value: line,
                message: 'Missing required coordinate fields',
                suggestion: 'Ensure latitude/longitude or lat/lng columns exist'
              });
            }
          } else {
            const validationResult = CSVValidator.validateLine(line, headers, lineNumber);
            if (validationResult.errors.length > 0) {
              result.errors.push(...validationResult.errors);
            }
            if (validationResult.data) {
              result.data.push(validationResult.data);
            }
          }
          lineNumber++;
        });
        
        callback();
      }
    });

    return new Promise((resolve) => {
      stream
        .pipe(transformer)
        .on('finish', () => {
          result.isValid = result.errors.length === 0;
          resolve(result);
        });
    });
  }

  private static parseHeaders(headerLine: string): string[] {
    return headerLine
      .split(',')
      .map(header => header.toLowerCase().trim());
  }

  private static validateHeaders(headers: string[]): boolean {
    const hasLatitude = headers.some(h => 
      this.HEADERS.LATITUDE.includes(h));
    const hasLongitude = headers.some(h => 
      this.HEADERS.LONGITUDE.includes(h));
    return hasLatitude && hasLongitude;
  }

  private static validateLine(
    line: string,
    headers: string[],
    lineNumber: number
  ): { errors: ValidationError[], data?: MapPoint } {
    const errors: ValidationError[] = [];
    const values = line.split(',').map(v => v.trim());
    
    if (values.length !== headers.length) {
      errors.push({
        line: lineNumber,
        field: 'line',
        value: line,
        message: 'Invalid number of columns',
        suggestion: `Expected ${headers.length} columns, got ${values.length}`
      });
      return { errors };
    }

    const record: Record<string, string> = {};
    headers.forEach((header, index) => {
      record[header] = values[index];
    });

    const coordinates = this.extractCoordinates(record, headers);
    if (!coordinates) {
      errors.push({
        line: lineNumber,
        field: 'coordinates',
        value: `${values}`,
        message: 'Invalid coordinate values',
        suggestion: 'Ensure coordinates are in decimal format (e.g., 41.40338, 2.17403)'
      });
      return { errors };
    }

    try {
      const mapPoint = createMapPoint({
        ...record,
        latlng: coordinates
      });
      return { errors, data: mapPoint };
    } catch (error) {
      errors.push({
        line: lineNumber,
        field: 'processing',
        value: line,
        message: 'Failed to create map point',
        suggestion: error instanceof Error ? error.message : 'Unknown error'
      });
      return { errors };
    }
  }

  private static extractCoordinates(
    record: Record<string, string>,
    headers: string[]
  ): [number, number] | null {
    let lat: number | null = null;
    let lng: number | null = null;

    // Find latitude field
    const latField = headers.find(h => this.HEADERS.LATITUDE.includes(h));
    const lngField = headers.find(h => this.HEADERS.LONGITUDE.includes(h));

    if (!latField || !lngField) return null;

    lat = this.parseCoordinate(record[latField], true);
    lng = this.parseCoordinate(record[lngField], false);

    if (lat === null || lng === null) return null;
    
    return [lat, lng];
  }

  private static parseCoordinate(value: string, isLatitude: boolean): number | null {
    if (!value) return null;

    // Try decimal format
    if (this.COORDINATE_PATTERNS.DECIMAL.test(value)) {
      const coord = parseFloat(value);
      const range = isLatitude ? 
        this.COORDINATE_PATTERNS.LAT_RANGE : 
        this.COORDINATE_PATTERNS.LNG_RANGE;
      
      if (coord >= range[0] && coord <= range[1]) {
        return coord;
      }
    }

    // Try DMS format
    const dmsMatch = value.match(this.COORDINATE_PATTERNS.DMS);
    if (dmsMatch) {
      const degrees = parseInt(dmsMatch[1]);
      const minutes = parseInt(dmsMatch[2]);
      const seconds = parseFloat(dmsMatch[3]);
      const direction = dmsMatch[5];

      let decimal = degrees + (minutes / 60) + (seconds / 3600);
      if (direction === 'S' || direction === 'W') {
        decimal *= -1;
      }

      return decimal;
    }

    return null;
  }
}
```

And here are the corresponding unit tests:

```typescript
// csvValidator.test.ts
import { CSVValidator } from './csvValidator';
import { Readable } from 'stream';

describe('CSVValidator', () => {
  const createReadStream = (content: string): NodeJS.ReadableStream => {
    return Readable.from([content]);
  };

  it('should validate valid CSV data', async () => {
    const csv = 'lat,lng,name\n41.40338,2.17403,Barcelona';
    const result = await CSVValidator.validateCSV(createReadStream(csv));
    
    expect(result.isValid).toBe(true);
    expect(result.errors).toHaveLength(0);
    expect(result.data).toHaveLength(1);
    expect(result.data[0].latlng).toEqual([41.40338, 2.17403]);
  });

  it('should handle missing coordinates', async () => {
    const csv = 'name,description\nBarcelona,Nice city';
    const result = await CSVValidator.validateCSV(createReadStream(csv));
    
    expect(result.isValid).toBe(false);
    expect(result.errors[0].message).toContain('Missing required coordinate fields');
  });

  it('should validate coordinate ranges', async () => {
    const csv = 'lat,lng\n91,180';
    const result = await CSVValidator.validateCSV(createReadStream(csv));
    
    expect(result.isValid).toBe(false);
    expect(result.errors[0].message).toContain('Invalid coordinate values');
  });

  it('should handle DMS format', async () => {
    const csv = 'latitude,longitude\n41°24\'12.2"N,2°10\'26.5"E';
    const result = await CSVValidator.validateCSV(createReadStream(csv));
    
    expect(result.isValid).toBe(true);
    expect(result.data[0].latlng[0]).toBeCloseTo(41.40338, 4);
    expect(result.data[0].latlng[1]).toBeCloseTo(2.17403, 4);
  });

  it('should process large files efficiently', async () => {
    const rows = Array(10000)
      .fill(null)
      .map(() => '41.40338,2.17403,Barcelona')
      .join('\n');
    const csv = `lat,lng,name\n${rows}`;
    
    const result = await CSVValidator.validateCSV(createReadStream(csv));
    expect(result.isValid).toBe(true);
    expect(result.data).toHaveLength(10000);
  });
});
```

This implementation:

1. Uses streaming for memory-efficient processing of large files
2. Supports multiple coordinate formats (decimal and DMS)
3. Provides detailed error reporting with line numbers and suggestions
4. Validates coordinate ranges
5. Handles different header names for coordinates
6. Includes comprehensive unit tests
7. Integrates with existing createMapPoint helper

The validator can be used like this:

```typescript
const fs = require('fs');

async function validateCSVFile(filePath: string) {
  const stream = fs.createReadStream(filePath);
  const result = await CSVValidator.validateCSV(stream);
  
  if (!result.isValid) {
    console.log('Validation errors:');
    result.errors.forEach(error => {
      console.log(`Line ${error.line}: ${error.message}`);
      if (error.suggestion) {
        console.log(`Suggestion: ${error.suggestion}`);
      }
    });
  } else {
    console.log(`Successfully validated ${result.data.length} map points`);
  }
  
  return result;
}
```