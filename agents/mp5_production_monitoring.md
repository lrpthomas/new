# MP-5: Production Monitoring

Generated by DEPLOY_AGENT

I'll help you create a comprehensive production monitoring system for Maptap. I'll break this down into multiple components with implementation code.

1. First, let's enhance the error handling and logging system:

```typescript
// src/services/logger.ts
import winston from 'winston';

const logger = winston.createLogger({
  level: 'info',
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.json()
  ),
  transports: [
    new winston.transports.File({ filename: 'logs/error.log', level: 'error' }),
    new winston.transports.File({ filename: 'logs/combined.log' }),
    new winston.transports.Console({
      format: winston.format.combine(
        winston.format.colorize(),
        winston.format.simple()
      )
    })
  ]
});

export default logger;

// src/middleware/errorHandler.ts
import { Request, Response, NextFunction } from 'express';
import logger from '../services/logger';

export const errorHandler = (
  error: any,
  req: Request,
  res: Response,
  next: NextFunction
) => {
  const status = error.status || 500;
  const message = error.message || 'Internal Server Error';

  logger.error({
    message,
    status,
    stack: error.stack,
    path: req.path,
    method: req.method,
    requestId: req.headers['x-request-id']
  });

  res.status(status).json({
    status,
    message,
    requestId: req.headers['x-request-id']
  });
};
```

2. GitHub Actions CI/CD Pipeline:

```yaml
# .github/workflows/ci.yml
name: Maptap CI/CD

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v2
    
    - name: Use Node.js
      uses: actions/setup-node@v2
      with:
        node-version: '16.x'
        
    - name: Install dependencies
      run: npm ci
      
    - name: Run tests
      run: npm test
      
    - name: Build
      run: npm run build
      
    - name: Run linter
      run: npm run lint

  deploy:
    needs: build
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'

    steps:
    - name: Deploy to production
      run: |
        # Add your deployment commands here
```

3. Health Check Endpoints:

```typescript
// src/routes/health.ts
import express from 'express';
import prometheus from 'prom-client';

const router = express.Router();
const register = new prometheus.Registry();

// Add basic metrics
const httpRequestDurationMicroseconds = new prometheus.Histogram({
  name: 'http_request_duration_ms',
  help: 'Duration of HTTP requests in ms',
  labelNames: ['method', 'route', 'status_code'],
  buckets: [0.1, 5, 15, 50, 100, 500]
});

register.registerMetric(httpRequestDurationMicroseconds);

router.get('/health', (req, res) => {
  res.json({ status: 'healthy' });
});

router.get('/ready', (req, res) => {
  // Add your readiness checks here
  res.json({ status: 'ready' });
});

router.get('/metrics', async (req, res) => {
  res.set('Content-Type', register.contentType);
  res.end(await register.metrics());
});

export default router;
```

4. Performance Monitoring Middleware:

```typescript
// src/middleware/performance.ts
import { Request, Response, NextFunction } from 'express';
import logger from '../services/logger';

export const performanceMonitor = (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  const start = process.hrtime();

  res.on('finish', () => {
    const [seconds, nanoseconds] = process.hrtime(start);
    const duration = seconds * 1000 + nanoseconds / 1000000;

    logger.info({
      type: 'request_completed',
      duration,
      method: req.method,
      path: req.path,
      statusCode: res.statusCode
    });
  });

  next();
};
```

5. Production Configuration:

```typescript
// src/config/production.ts
export default {
  port: process.env.PORT || 3000,
  nodeEnv: 'production',
  logLevel: 'info',
  monitoring: {
    enableMetrics: true,
    metricsPort: 9090,
    healthCheckInterval: 30000
  },
  redis: {
    host: process.env.REDIS_HOST,
    port: process.env.REDIS_PORT
  },
  database: {
    url: process.env.DATABASE_URL,
    poolSize: 20
  }
};
```

6. Dockerfile for production:

```dockerfile
# Dockerfile
FROM node:16-alpine

WORKDIR /app

COPY package*.json ./
RUN npm ci --only=production

COPY dist ./dist

EXPOSE 3000
CMD ["node", "dist/index.js"]
```

7. Docker Compose for production:

```yaml
# docker-compose.prod.yml
version: '3.8'

services:
  app:
    build: .
    ports:
      - "3000:3000"
    environment:
      - NODE_ENV=production
      - DATABASE_URL=postgresql://user:pass@db:5432/maptap
      - REDIS_HOST=redis
      - REDIS_PORT=6379
    depends_on:
      - db
      - redis
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:3000/health"]
      interval: 30s
      timeout: 10s
      retries: 3

  db:
    image: postgres:13
    environment:
      POSTGRES_USER: user
      POSTGRES_PASSWORD: pass
      POSTGRES_DB: maptap
    volumes:
      - postgres_data:/var/lib/postgresql/data

  redis:
    image: redis:6-alpine
    volumes:
      - redis_data:/data

volumes:
  postgres_data:
  redis_data:
```

8. Integration in main application:

```typescript
// src/index.ts
import express from 'express';
import config from './config/production';
import { errorHandler } from './middleware/errorHandler';
import { performanceMonitor } from './middleware/performance';
import healthRoutes from './routes/health';
import logger from './services/logger';

const app = express();

// Middleware
app.use(performanceMonitor);
app.use(express.json());

// Routes
app.use('/', healthRoutes);

// Error handling
app.use(errorHandler);

app.listen(config.port, () => {
  logger.info(`Server started on port ${config.port}`);
});
```

To complete the monitoring setup, you should also:

1. Set up alerting with a service like PagerDuty or OpsGenie
2. Configure external monitoring (e.g., Pingdom or UptimeRobot)
3. Set up log aggregation (e.g., ELK Stack or DataDog)
4. Configure metrics visualization (e.g., Grafana)

Here's a monitoring setup script:

```bash
#!/bin/bash
# setup-monitoring.sh

# Install dependencies
npm install winston prometheus-client prom-client @elastic/elasticsearch

# Create necessary directories
mkdir -p logs
mkdir -p monitoring

# Set up basic alerting (example with node-notifier)
npm install node-notifier

# Create monitoring documentation
cat > monitoring-readme.md << EOL
# Maptap Monitoring Guide

## Endpoints
- /health - Basic health check
- /ready - Readiness probe
- /metrics - Prometheus metrics

## Logs
- Location: ./logs
- Format: JSON
- Levels: error, warn, info, debug

## Metrics
- HTTP request duration
- Error rates
- System metrics

## Alerts
Configure in monitoring/alerts.json
EOL
```

This gives you a solid foundation for production monitoring. You can expand each component based on your specific needs.